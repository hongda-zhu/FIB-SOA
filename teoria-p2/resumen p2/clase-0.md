### **Clase 1**

Esta clase discute principalmente los **métodos de asignación de bloques de datos en el sistema de ficheros**, es decir, cómo se almacena el contenido de un fichero (sus bloques de datos) en el disco y cómo estos bloques se asocian con los metadatos del fichero (especialmente el i-nodo). Este contenido está estrechamente relacionado con el capítulo de "Implementación" en "tema5.pdf", particularmente la discusión sobre las diferentes estrategias de asignación.

* **Resumen de los métodos de asignación:** El profesor plantea primero la pregunta: un fichero está compuesto por bloques de datos, ¿cómo se organizan estos bloques en el disco? ¿Qué metadatos necesita almacenar el i-nodo para encontrar los bloques que pertenecen a un fichero específico? Un principio básico es que un bloque de datos solo puede pertenecer a un fichero a la vez.
* **1. Asignación Contigua:**
    * **Principio:** Se asigna un conjunto de bloques de disco contiguos a un fichero. El i-nodo almacena el número de bloque inicial y el tamaño del fichero (o el número de bloques).
    * **Acceso:**
        * Acceso secuencial: Muy bueno, porque los bloques son contiguos y el siguiente bloque es simplemente el número de bloque actual + 1.
        * Acceso aleatorio: También muy bueno, ya que el número de bloque objetivo se puede calcular directamente a partir del desplazamiento y el tamaño del bloque.
    * **Problemas:**
        * **Dificultad para el crecimiento del fichero:** Si un fichero necesita crecer después de su creación pero no hay suficientes bloques libres contiguos a continuación, es necesario mover el fichero completo, lo que tiene un coste muy alto.
        * **Fragmentación externa:** Se crean muchos pequeños bloques libres no contiguos en el disco, que no pueden ser utilizados para almacenar ficheros más grandes, aunque el espacio libre total sea suficiente.
        * **Necesidad de conocer el tamaño del fichero de antemano:** Para evitar mover el fichero, normalmente es necesario conocer de antemano el espacio máximo que necesitará, lo que no es práctico en muchos casos.
    * **Casos de uso:** Se utiliza principalmente en medios de solo lectura, como CD-ROM, DVD y Blu-ray (siguiendo el estándar ISO 9660), porque el tamaño de los ficheros en estos medios es fijo.
* **2. Asignación Encadenada:**
    * **Principio:** Los bloques de datos de un fichero pueden estar dispersos en cualquier lugar del disco. El final de cada bloque de datos (por ejemplo, los últimos 4 bytes) contiene un puntero (número de bloque) al siguiente bloque de datos del fichero. El puntero en el último bloque de datos es NULL o una marca especial. El i-nodo almacena el número del primer bloque de datos y el tamaño del fichero.
    * **Ventajas:**
        * **Asignación dinámica:** Los ficheros pueden crecer y reducirse fácilmente.
        * **Sin fragmentación externa:** Se puede utilizar cualquier bloque libre.
    * **Acceso:**
        * Acceso secuencial: Bueno, se encuentra el siguiente bloque a través del puntero dentro del bloque.
        * Acceso aleatorio: Muy malo. Para acceder al bloque `i` de un fichero, se debe empezar desde el primer bloque y leer secuencialmente los `i-1` bloques anteriores siguiendo la cadena de punteros, lo que implica una gran cantidad de búsquedas y lecturas en el disco.
    * **Aplicaciones:** Utilizado en MS-DOS 2.0, pero mejorado en sistemas posteriores debido al bajo rendimiento del acceso aleatorio.
* **3. Asignación Encadenada con Tabla de Asignación de Ficheros (FAT):**
    * **Principio:** Para solucionar la lentitud del acceso aleatorio en la asignación encadenada, todos los punteros de enlace de los bloques de datos (es decir, cuál es el siguiente bloque de cada bloque) se centralizan en un área especial al principio del disco, llamada Tabla de Asignación de Ficheros (FAT). Cada entrada de la tabla FAT corresponde a un bloque de datos en el disco, y su contenido es el número de bloque del siguiente bloque de datos del fichero, una marca de fin de fichero, o una marca de bloque libre. El i-nodo (o la entrada de directorio) almacena el número de bloque del primer bloque de datos del fichero y su tamaño.
    * **Optimización:** Al iniciar el sistema, toda la tabla FAT se carga en la memoria. De esta manera, el proceso de búsqueda de la cadena de bloques de un fichero se realiza en memoria, lo cual es muy rápido.
    * **Acceso:**
        * Acceso secuencial: Bueno.
        * Acceso aleatorio: Muy bueno, porque se puede localizar rápidamente cualquier bloque de datos en la tabla FAT en memoria.
    * **Ventajas:** Asignación dinámica, sin fragmentación externa y buen rendimiento en acceso aleatorio.
    * **Desventajas:** El tamaño de la tabla FAT es proporcional a la capacidad del disco. En discos muy grandes, la tabla FAT puede ocupar mucha memoria. Además, la integridad de la FAT es crucial; si se corrompe, todo el sistema de ficheros puede volverse inaccesible (por eso existen copias de seguridad de la FAT).
    * **Aplicaciones:** Ampliamente utilizado en versiones posteriores de MS-DOS, Windows (FAT12, FAT16, FAT32, exFAT), así como en unidades USB, tarjetas SD y otros dispositivos de almacenamiento extraíbles.
* **4. Asignación Indexada:**
    * **Principio:** Se crea uno o más bloques de índices para cada fichero. Un bloque de índices no almacena datos del fichero, sino que almacena punteros (una lista de números de bloque) a los bloques de datos reales del fichero. El i-nodo almacena un puntero a este (o al primer) bloque de índices, así como el tamaño del fichero.
    * **Problema que resuelve:** Evita el problema del tamaño excesivo de la tabla FAT, ya que cada fichero gestiona su propia información de índices.
    * **Crecimiento del fichero:** Si un bloque de índices no puede contener todos los punteros a los bloques de datos de un fichero, se pueden enlazar varios bloques de índices (formando una cadena de bloques de índices) o utilizar un índice multinivel.
    * **Acceso:**
        * Acceso secuencial: Aceptable, pero ligeramente peor que con FAT, ya que primero hay que leer el bloque de índices y luego leer los bloques de datos basándose en la información de este.
        * Acceso aleatorio: Bueno, ya que se puede localizar directamente un bloque de datos a través del bloque de índices.
    * **Aplicaciones:** Esta es la idea fundamental de muchos sistemas de ficheros modernos (como NTFS), aunque suelen tener optimizaciones más complejas.
* **5. Asignación Indexada Multinivel:**
    * **Principio:** Es una extensión de la asignación indexada, especialmente adecuada para ficheros grandes. El i-nodo contiene directamente un pequeño número de punteros a bloques de datos (**punteros a bloques directos**), así como punteros a bloques de índice de primer nivel, segundo nivel e incluso tercer nivel.
        * **Bloque indirecto simple:** Un puntero en el i-nodo apunta a un bloque de índices, y todas las entradas de ese bloque de índices apuntan a bloques de datos.
        * **Bloque doblemente indirecto:** Un puntero en el i-nodo apunta a un bloque de índices, y todas las entradas de ese bloque apuntan a otros bloques de índices (índices de segundo nivel), cuyas entradas, a su vez, apuntan a los bloques de datos.
        * **Bloque triplemente indirecto:** Añade otro nivel de indexación.
    * **Ventajas:** Permite soportar ficheros muy grandes, mientras que el acceso a ficheros pequeños (que solo necesitan bloques directos) es muy eficiente. El coste del acceso se ajusta dinámicamente según el tamaño del fichero.
    * **Aplicaciones:** Sistemas de ficheros de Unix/Linux (como Ext2, Ext3, Ext4) utilizan ampliamente este método. Por ejemplo, el profesor mencionó que con 10 bloques directos, 1 bloque indirecto simple, 1 doblemente indirecto y 1 triplemente indirecto, si el tamaño del bloque es de 4KB y el tamaño del puntero es de 4 bytes, se puede soportar un fichero de hasta 4PB.
* **Resumen de la estructura de una partición de disco:**
    * **Registro de arranque principal (MBR - Master Boot Record):** El primer sector del disco duro, que contiene el cargador de arranque y la tabla de particiones (hasta 4 particiones primarias).
    * **Estructura interna de la partición:**
        1.  **Superbloque:** Ubicado al inicio de la partición, contiene los metadatos de la partición, como el tamaño de la partición, el tamaño de los bloques, el número total de i-nodos, el mapa de bits de i-nodos libres y el mapa de bits de bloques de datos libres. Se carga en memoria al iniciar el sistema y se escribe periódicamente en el disco. Para la tolerancia a fallos, suelen existir copias de seguridad del superbloque.
        2.  **Lista de i-nodos:** Un área para almacenar todos los i-nodos. En los sistemas antiguos, su tamaño era fijo, pero los sistemas modernos pueden ajustarlo dinámicamente.
        3.  **Área de datos:** Almacena el contenido de los ficheros y los bloques de índices.

### **Clase 2**

Esta clase parece haber introducido principalmente la **evolución del sistema de ficheros, en particular la introducción de la estructura de directorios y los i-nodos**, para hacer frente al creciente volumen de almacenamiento y número de ficheros. Esto se corresponde con la sección sobre la "Implementación" del sistema de ficheros en "tema5.pdf", especialmente en lo que respecta a la gestión de directorios e i-nodos, así como con los conceptos de sistema de ficheros mencionados en "SOA_Resumen_amr (2).pdf".

* **Sistemas de ficheros tempranos y metadatos:** La clase comienza con los primeros sistemas de ficheros, como los de los disquetes. El espacio de almacenamiento era limitado y solo se podían almacenar unos pocos ficheros (por ejemplo, de 8 a 16). Cada entrada de fichero contenía el nombre del fichero (como el formato 8.3) y algunos **metadatos**, que son la información necesaria para acceder al contenido del fichero.
* **La evolución por el aumento de la capacidad de almacenamiento:** Con la llegada de los discos duros, la capacidad de almacenamiento aumentó drásticamente del nivel de KB al de MB. Esto permitió almacenar ficheros más grandes y en mayor cantidad, lo que requirió nuevas formas de organizar el sistema de ficheros.
* **Introducción de los directorios:** Cuando el número de ficheros llegó a cientos o miles, la gestión mediante una simple lista ya no era adecuada. Así se introdujo el concepto de **directorios**. Un directorio es en sí mismo un tipo especial de fichero que se utiliza para organizar y almacenar entradas de otros ficheros o directorios.
    * Inicialmente, los directorios formaban una **estructura de árbol**. Las entradas de directorio contenían el nombre del fichero, metadatos y un indicador de si la entrada era un fichero o un subdirectorio.
* **De la estructura de árbol a la de grafo y el nacimiento del i-nodo:** A medida que la capacidad de los discos crecía exponencialmente (GB, TB), las rutas absolutas de los ficheros se volvían muy largas, dificultando la gestión para los usuarios y la búsqueda para el sistema. Para resolver este problema y proporcionar un enlace más flexible (como los enlaces duros), la estructura de directorios evolucionó de un árbol estricto a un **grafo acíclico dirigido (DAG)**, e incluso permitiendo ciclos (aunque normalmente se evitan o limitan mediante mecanismos).
    * Esta estructura de grafo introdujo un problema central: si varias entradas de directorio pueden apuntar a los mismos datos físicos de un fichero, ¿dónde deben almacenarse los metadatos del fichero (como el tamaño, los permisos, la ubicación de los bloques de datos)? Si cada entrada de directorio duplicara una copia, se producirían redundancias e inconsistencias de datos.
    * La solución fue la introducción del **i-nodo (nodo-i o nodo de información)**:
        1.  **Desacoplamiento del nombre del fichero de los datos/metadatos:** El nombre del fichero ya no está directamente ligado a los datos físicos ni a la mayoría de los metadatos del fichero.
        2.  **La función del i-nodo:**
            * Almacena los metadatos principales del fichero, como: tipo de fichero (fichero normal, directorio, enlace, etc.), permisos, propietario, tamaño, marcas de tiempo, punteros a los bloques de datos del fichero (o información de indexación), etc.
            * Contiene un **contador de referencias (link count)**, que registra cuántas entradas de directorio (nombres de fichero) apuntan a este i-nodo. Cuando el contador de referencias llega a 0, significa que el fichero ya no tiene ningún nombre asociado y el i-nodo y los bloques de datos que ocupa pueden ser liberados.
        3.  **La evolución de las entradas de directorio:** El contenido de un directorio se simplificó a una serie de pares **(nombre de fichero, número de i-nodo)**. Esta forma de apuntar desde un nombre de fichero a un i-nodo se denomina **enlace duro (hard link)**.
* **Fundamentos de la gestión de bloques de disco:**
    * **Sectores vs. Bloques:** La unidad mínima de lectura/escritura del hardware del disco es el sector (normalmente 512 bytes o 4 KB). Para facilitar la gestión y mejorar la eficiencia, el sistema operativo suele realizar la asignación de espacio en disco y las operaciones de E/S en unidades de **bloques**. Un bloque está compuesto por uno o más sectores contiguos.
    * **Discusión sobre los métodos de asociación de bloques y sectores:**
        1.  **Bloques de tamaño fijo que no comparten sectores:** Por ejemplo, un bloque se fija en 4 KB, compuesto por 8 sectores de 512 bytes. Este es el método más común y sencillo. Si el tamaño de un fichero no es un múltiplo entero del tamaño del bloque, el último bloque generará **fragmentación interna** (espacio no utilizado dentro del bloque). El profesor señaló que este es el método más utilizado actualmente porque es fácil de implementar, tiene un buen rendimiento y la fragmentación interna suele ser aceptable.
        2.  **Bloques de tamaño variable que no comparten sectores:** Se intenta que el tamaño del bloque se adapte al tamaño del fichero para reducir la fragmentación interna, pero esto aumenta la complejidad de la gestión. Todavía puede haber fragmentación interna a nivel de sector.
        3.  **Bloques de tamaño variable que permiten compartir sectores:** Puede eliminar casi por completo la fragmentación interna, pero la complejidad de la gestión y el acceso aumenta considerablemente.
* **Pregunta pendiente de la clase:** Finalmente, el profesor planteó una pregunta: ¿cómo se asocian estos bloques de datos (gestionados con un tamaño fijo y sin compartir sectores) con el i-nodo? Esto sentó las bases para el contenido de la siguiente clase (es decir, la que ahora analizamos como "Clase 1 (archivo original: clase3.txt.txt)"), las estrategias de asignación de bloques de datos.

### **Clase 3**

El núcleo de esta clase es la **independencia de dispositivo**, y las estructuras y datos internos del sistema operativo necesarios para lograrla, como los ficheros de dispositivo, los controladores (drivers) y el flujo interno de llamadas al sistema como `open`. Este contenido se explica en detalle en las secciones "Conceptos básicos", "Estructuras de datos básicas" y "Visión global" de "tema5.pdf", y también se relaciona con las secciones sobre "Syscalls", "Interrupciones y excepciones" de "SOA_Resumen_amr (2).pdf".

* **El objetivo de la independencia de dispositivo:** El profesor explicó que un objetivo importante de los sistemas operativos modernos es ocultar la complejidad y diversidad del hardware subyacente a los usuarios y aplicaciones. Los usuarios utilizan una interfaz unificada (como las llamadas al sistema `open`, `read`, `write`, `close`) para acceder a diversos dispositivos (como discos duros, tarjetas gráficas, interfaces de red, teclados, ratones), sin necesidad de preocuparse por los detalles específicos del hardware. El sistema operativo se encarga internamente de gestionar estas diferencias, y esto es la independencia de dispositivo.
* **Clasificación de dispositivos en Linux:** Para lograr la independencia de dispositivo, Linux (y otros sistemas tipo Unix) abstraen y clasifican los dispositivos:
    1.  **Dispositivos físicos:** Se refiere al hardware real, como unidades de disco duro, ratones, teclados, tarjetas gráficas, etc. El código que interactúa directamente con el dispositivo físico es altamente dependiente del hardware específico y suele ser proporcionado por el fabricante del hardware, conocido como **controlador de dispositivo (Device Driver)**.
    2.  **Dispositivos lógicos:** Es una abstracción que el sistema operativo proporciona para el acceso a E/S. Son visibles para el usuario y se presentan como ficheros especiales en el sistema de ficheros (generalmente en el directorio `/dev`).
        * Un dispositivo lógico puede estar asociado a un dispositivo físico (por ejemplo, `/dev/sda` representa el primer disco duro SATA).
        * También puede no corresponder directamente a un dispositivo físico, sino que proporciona algún servicio o abstracción (por ejemplo, `/dev/null`, `/dev/zero` o un pseudoterminal `/dev/tty`).
        * Su función es: abstraer el hardware, agregar dispositivos físicos o añadir nuevas funcionalidades al sistema de ficheros.
    3.  **Dispositivos virtuales:** Es una instancia de un dispositivo lógico y es el objeto que el proceso de usuario realmente manipula. Cuando un proceso abre un dispositivo lógico, el sistema crea una instancia de dispositivo virtual para él, que mantiene el estado de acceso específico de ese proceso a ese dispositivo lógico (como la posición de lectura/escritura actual). Esto permite que múltiples procesos accedan al mismo dispositivo lógico simultáneamente (o secuencialmente) sin interferir entre sí (o compartiéndolo según reglas específicas).
* **Asociación entre dispositivos:**
    * **Asociación entre dispositivo lógico y físico:** Se establece a través de los controladores de dispositivo y llamadas al sistema específicas (como `mknod` en Linux). `mknod` crea un fichero de dispositivo (dispositivo lógico), que almacena en su i-nodo el **número mayor (major number)** y el **número menor (minor number)**. El número mayor identifica el tipo de dispositivo o el controlador, mientras que el número menor se utiliza para distinguir entre múltiples dispositivos físicos del mismo tipo.
    * **Asociación entre dispositivo virtual y lógico:** Se establece a través de la llamada al sistema `open`. Cuando un proceso hace `open` a un fichero de dispositivo (dispositivo lógico), el núcleo crea una instancia de dispositivo virtual.
* **Proceso de arranque (Boot) e identificación de hardware:**
    * **Inicialización de BIOS/UEFI:** Al encender, la BIOS/UEFI realiza primero una detección e inicialización básica del hardware (CPU, memoria, etc.).
    * **Selección del dispositivo de arranque:** La BIOS/UEFI busca un dispositivo de arranque (como un disco duro, una unidad USB, la red) según la configuración.
    * **Carga del sistema operativo y detección de hardware:** Una vez que se carga el núcleo del sistema operativo, realiza una detección de hardware más completa. Consulta varios buses (como PCI, USB, SATA) para identificar los dispositivos conectados.
    * **VID y PID:** Los dispositivos de hardware suelen informar al sistema operativo de dos identificadores importantes: el **ID de vendedor (VID)** y el **ID de producto (PID)**.
* **Controladores (Drivers):**
    * El sistema operativo utiliza el VID y el PID para encontrar y cargar el **controlador de dispositivo** adecuado. Los controladores son módulos de código que contienen el código para interactuar con un hardware específico.
    * Al cargar un controlador, el núcleo crea un **descriptor de dispositivo**. Este descriptor almacena el VID, PID, número mayor, número menor y una tabla de punteros a las funciones de operaciones estándar implementadas por el controlador (como `open`, `read`, `write`, `close`, `ioctl`, etc.). El sistema operativo utiliza esta tabla para invocar las funciones específicas del controlador.
* **Llamada al sistema `mknod`:**
    * Se utiliza para crear ficheros especiales, incluidos los ficheros de dispositivo (dispositivos lógicos).
    * Crea un i-nodo en el sistema de ficheros y almacena el número mayor y menor en él.
    * `mknod` en sí mismo no verifica si los números mayor/menor corresponden a un controlador y un dispositivo físico existentes y disponibles; solo se encarga de crear este "punto de entrada" en el sistema de ficheros.
* **Flujo interno de la llamada al sistema `open` (para un fichero de dispositivo):**
    1.  **Resolución de ruta:** El VFS (Sistema de Ficheros Virtual) encuentra el i-nodo del fichero de dispositivo correspondiente basándose en la ruta.
    2.  **Acceso a la tabla de i-nodos:** Carga este i-nodo en la tabla de i-nodos en memoria (si no estaba ya cargado).
    3.  **Búsqueda del controlador de dispositivo:** Obtiene los números mayor y menor del i-nodo. Utiliza el número mayor para encontrar el controlador de dispositivo correspondiente en la lista de controladores del núcleo y obtener su descriptor de dispositivo (que incluye la tabla de punteros a funciones de operación). En este punto, el dispositivo lógico (representado por el i-nodo) se asocia con el código real del controlador.
    4.  **Creación de la instancia de fichero abierto:**
        * Se crea una nueva entrada en la **tabla global de ficheros abiertos** del núcleo. Esta entrada contiene un puntero a la tabla de i-nodos en memoria, el modo de lectura/escritura actual, el desplazamiento de lectura/escritura actual (offset) y otra información dinámica.
        * Se crea una nueva entrada en la **tabla de descriptores de fichero** del propio proceso, que apunta a la entrada correspondiente en la tabla global de ficheros abiertos.
    5.  **Devolución del descriptor de fichero:** La llamada al sistema `open` devuelve al proceso de usuario el índice de su tabla de descriptores de fichero, es decir, el **descriptor de fichero**, también conocido como dispositivo virtual. Las operaciones posteriores como `read` y `write` utilizarán este descriptor de fichero.
    * Tanto la tabla global de ficheros abiertos como la tabla de i-nodos utilizan contadores de referencias para gestionar el ciclo de vida de sus entradas.
* **Llamada al sistema `fork`:** El proceso hijo hereda la tabla de descriptores de fichero del padre, lo que significa que el hijo puede acceder a los mismos ficheros (o dispositivos) abiertos por el padre y compartir las mismas entradas de la tabla global de ficheros abiertos (y, por lo tanto, compartir el desplazamiento de lectura/escritura, a menos que se realicen operaciones específicas después). El contador de referencias de la entrada de la tabla global de ficheros abiertos se incrementa.
* **Llamada al sistema `read` (para un fichero de dispositivo):**
    1.  El proceso de usuario proporciona el descriptor de fichero, la dirección del búfer y el número de bytes a leer.
    2.  El núcleo encuentra la entrada correspondiente en la tabla global de ficheros abiertos a través del descriptor de fichero en la tabla del proceso.
    3.  Desde la entrada de la tabla global de ficheros abiertos, obtiene el puntero al i-nodo y, a su vez, el puntero a la tabla de funciones de operación del controlador de dispositivo.
    4.  Invoca la función `read` del controlador, pasándole los parámetros necesarios (como el desplazamiento, el búfer, la cantidad, el número menor, etc.).
    5.  La función `read` del controlador interactúa con el dispositivo físico para obtener los datos y los copia en el búfer proporcionado por el usuario.
* **El problema del bloqueo en la E/S síncrona:** Al realizar operaciones de E/S (especialmente en dispositivos lentos como los discos duros), si se utiliza un modo síncrono, el proceso (o hilo) que solicita la E/S se bloqueará hasta que la operación se complete. En sistemas operativos antiguos o simples, esto podría dejar la CPU inactiva, desperdiciando recursos computacionales. La clase anticipa la solución: mediante la introducción de gestores de E/S dedicados y mecanismos asíncronos, se permite que la CPU realice otras tareas mientras espera la E/S.

### **Clase 4**

Esta clase profundiza en la **gestión de E/S**, en particular en los **mecanismos de implementación de la E/S síncrona y asíncrona, y el papel del gestor (o manejador) de dispositivos** en ello. Es una respuesta más detallada al problema del bloqueo de E/S planteado al final de la Clase 3 (según el nuevo orden, es decir, el original clase2.txt.txt). El contenido relevante se describe en detalle en las secciones "Acceso a dispositivo", "E/S Síncrona con gestor" y "E/S Asíncrona con gestor" de "tema5.pdf", y también se relaciona con los conceptos de sincronización de procesos/hilos (como los semáforos) y el manejo de interrupciones de "SOA_Resumen_amr (2).pdf".

* **Repaso del problema del bloqueo en la E/S síncrona:** El profesor primero repasó la situación discutida anteriormente: cuando un hilo de usuario solicita una operación de E/S a través de una llamada al sistema (como `read`), si el núcleo accede directamente al dispositivo físico y espera a que termine, ese hilo de usuario se bloqueará en modo núcleo, especialmente si el dispositivo es lento (como un disco duro mecánico), desperdiciando recursos de la CPU.
* **Introducción de los gestores/manejadores de dispositivos:**
    * Para evitar que el hilo de usuario espere directamente al hardware, se introduce el **gestor de dispositivos**. Este suele ser uno o más hilos (o procesos) del núcleo dedicados a realizar las operaciones de E/S reales con uno o un grupo de dispositivos físicos.
    * Las solicitudes de E/S del hilo de usuario ya no impulsan directamente el hardware, sino que se envían al gestor de dispositivos correspondiente.
    * Una vez que el dispositivo físico completa la operación, notifica a la CPU mediante una **interrupción**, y el programa de servicio de interrupción despierta o notifica al gestor de dispositivos que esperaba esa interrupción.
* **Mecanismos de comunicación y sincronización con el gestor de dispositivos:**
    * **Descriptor de dispositivo del gestor:** También se crea una estructura similar a un descriptor de dispositivo para el propio gestor de dispositivos, que contiene funciones para procesar las solicitudes de E/S. El VFS o el subsistema de E/S de nivel superior dirigirá las solicitudes a las funciones de estos gestores, en lugar de directamente a las funciones del controlador del dispositivo físico.
    * **Cola de solicitudes y cola de resultados:**
        1.  **Cola de IORBs (Input/Output Request Blocks):** Cuando un hilo de usuario realiza una solicitud de E/S, el núcleo (o VFS) crea un **Bloque de Solicitud de E/S (IORB)**. El IORB contiene toda la información necesaria: tipo de operación (lectura/escritura), dispositivo de destino, dirección del búfer de usuario, cantidad de datos, desplazamiento del fichero, etc. Luego, este IORB se coloca en la cola de solicitudes del gestor de dispositivos correspondiente.
        2.  **Cola de finalización/Notificación de resultados:** Cuando el gestor de dispositivos completa la operación descrita en el IORB a través del controlador del dispositivo físico, almacena el resultado de la operación (estado de éxito/fallo, número de bytes realmente leídos/escritos, etc.) en algún lugar (posiblemente en el propio IORB o en una cola de resultados dedicada) y notifica al hilo de usuario que realizó la solicitud.
    * **Uso de semáforos para la sincronización:**
        1.  **Semáforo de operación (por IORB):** Cada IORB puede estar asociado a un semáforo, inicializado en 0 (semáforo de sincronización). Después de enviar el IORB a la cola de solicitudes, el hilo de usuario realiza una operación `wait` sobre su semáforo asociado, bloqueándose a sí mismo. Cuando el gestor de dispositivos termina de procesar el IORB, realiza una operación `signal` sobre ese semáforo para despertar al hilo de usuario en espera.
        2.  **Semáforo del gestor:** Para evitar que el gestor de dispositivos espere activamente (consumiendo CPU al sondear constantemente la cola de solicitudes), se le puede asignar un semáforo, inicializado en 0. El gestor realiza una operación `wait` sobre este semáforo cuando no hay solicitudes y se duerme. Cuando un hilo de usuario coloca un nuevo IORB en la cola de solicitudes, hace `signal` al semáforo del gestor para despertarlo y que procese la nueva solicitud.
        3.  **Semáforo de exclusión mutua para el acceso a la cola:** La cola de solicitudes y la posible cola de resultados son recursos compartidos, y necesitan ser protegidos con un semáforo de exclusión mutua (inicializado en 1) para evitar condiciones de carrera cuando múltiples hilos de usuario o el gestor acceden a ellas simultáneamente.
* **E/S Síncrona vs. Asíncrona:**
    * **E/S síncrona con gestor:** El mecanismo descrito anteriormente (el hilo de usuario se bloquea esperando a través del semáforo del IORB después de enviar la solicitud) implementa la E/S síncrona. Desde la perspectiva del hilo de usuario, sigue siendo "llamar y esperar el resultado". Pero a diferencia del bloqueo directo en el acceso al hardware, la CPU puede programar otros hilos para que se ejecuten mientras tanto.
    * **E/S asíncrona:** El objetivo es permitir que el hilo de usuario no se bloquee después de realizar una solicitud de E/S, sino que pueda continuar ejecutando otras tareas. La operación de E/S se realiza en segundo plano en paralelo. Esto generalmente se implementa a través de llamadas al sistema en dos fases:
        1.  **Iniciar la solicitud de E/S asíncrona:** El hilo de usuario llama a una función para enviar la solicitud de E/S (creando y pasando el IORB al gestor). Esta llamada devuelve inmediatamente un identificador de solicitud o un estado, sin esperar a que la E/S se complete.
        2.  **Consultar/esperar el resultado:** En un momento posterior, el hilo de usuario puede usar el identificador de solicitud devuelto en el paso anterior para llamar a otra función y verificar si la operación de E/S ha finalizado y obtener el resultado. Esta función de verificación se puede diseñar para que sea:
            * De espera bloqueante: si la operación no ha finalizado, se bloquea hasta que lo haga.
            * De comprobación no bloqueante (p. ej., con el flag `O_NONBLOCK`): si la operación no ha finalizado, devuelve inmediatamente un código de error específico (como `EAGAIN`), permitiendo que el hilo de usuario lo intente de nuevo más tarde.
            * Mediante una función de devolución de llamada (callback) o una señal: cuando la E/S se completa, el núcleo notifica asíncronamente al proceso de usuario (por ejemplo, mediante una señal o llamando a una función de devolución de llamada registrada por el usuario).
    * Los sistemas operativos modernos suelen implementar internamente las operaciones de E/S de bajo nivel de forma asíncrona (es decir, todas a través de gestores e interrupciones). La interfaz de E/S síncrona que se ofrece a los usuarios suele ser una envoltura sobre el mecanismo de E/S asíncrona: se inicia una solicitud asíncrona y luego se llama inmediatamente a una función que espera de forma bloqueante el resultado.

### **Clase 5**

Esta clase ofrece una **visión de la arquitectura por capas del sistema de ficheros**, integrando conceptos de clases anteriores sobre independencia de dispositivo, i-nodos, VFS (Sistema de Ficheros Virtual), soporte para diferentes tipos de sistemas de ficheros y optimización del rendimiento (como el almacenamiento en caché). Esto coincide en gran medida con las secciones "Implementación" y "Optimizaciones" de "tema5.pdf", especialmente con la descripción del VFS y la Buffer Cache.

* **Objetivos de los sistemas de ficheros modernos:**
    * Abstraer dispositivos físicos y lógicos.
    * Añadir nuevas características al sistema de ficheros (como tuberías (pipes), ficheros de dispositivo especiales como `/dev/null`).
    * Ser compatible con múltiples formatos de sistemas de ficheros subyacentes (como FAT32, NTFS, ext2/3/4).
    * Manejar la alta latencia del acceso a dispositivos físicos (como los discos).
* **Arquitectura en capas:** Para lograr los objetivos anteriores, la parte del sistema de ficheros de los sistemas operativos modernos suele adoptar un diseño en capas, donde cada capa es responsable de funciones específicas e interactúa con otras a través de interfaces bien definidas. Esto mejora la modularidad, la escalabilidad y la mantenibilidad.
    1.  **Sistema de Ficheros Virtual (VFS) / Sistema de Ficheros Lógico:**
        * Es la interfaz de nivel superior con la que las aplicaciones de usuario interactúan a través de llamadas al sistema.
        * El VFS proporciona un modelo de sistema de ficheros unificado y abstracto a las aplicaciones de nivel superior, ocultando las diferencias de los sistemas de ficheros subyacentes. Por ejemplo, en Linux, ya sea que la partición subyacente sea ext4, FAT32 o NTFS, el VFS presentará una vista uniforme de ficheros y directorios al estilo de Unix (como rutas, permisos, etc.).
        * En esta capa se implementa la interfaz de llamadas al sistema genéricas (como `sys_open`, `sys_read`, `sys_write`, `sys_close`, etc.).
        * Gestiona algunas estructuras de datos clave del núcleo, como:
            * **Tabla de descriptores de fichero del proceso (tabla de canales)**
            * **Tabla de ficheros abiertos a nivel de sistema**
            * **Tabla de V-nodes / Tabla de i-nodos virtuales:** Cuando se abre un fichero, el VFS crea un **V-node** para él. El V-node contiene información de fichero genérica e independiente del sistema de ficheros (como el tipo de fichero, una idea aproximada del tamaño, contador de referencias, etc.) y un conjunto de punteros a funciones de operación proporcionadas por el sistema de ficheros específico (por ejemplo, la función `read` de ext4, la función `read` de NTFS). También puede contener un puntero al i-nodo del sistema de ficheros específico (o una estructura equivalente), que es "opaco" para el VFS y es interpretado por el controlador del sistema de ficheros subyacente.
    2.  **Capa de controladores de sistemas de ficheros específicos:**
        * Se encuentra debajo del VFS y contiene módulos de controladores para cada tipo de sistema de ficheros específico (como ext4, XFS, Btrfs, NTFS, FAT32, ISO9660, etc.).
        * También incluye módulos para manejar dispositivos lógicos (como tuberías, ficheros de socket, `/dev/null`, etc.), que, aunque se presentan como objetos en el sistema de ficheros, su comportamiento y almacenamiento de datos son diferentes a los de los ficheros de disco.
        * Estos controladores entienden realmente la disposición en disco de un sistema de ficheros específico, sus estructuras de metadatos (como los i-nodos y la estructura de directorios de ext4, o las entradas de directorio y la tabla FAT de FAT) y cómo realizar operaciones de fichero (como buscar bloques de datos, asignar nuevos bloques, leer/escribir directorios, etc.).
        * Cuando el VFS necesita realizar una operación sobre un fichero (por ejemplo, el usuario llama a `read`), el VFS, a través del puntero de función guardado en el V-node, invoca la función `read` proporcionada por el controlador del sistema de ficheros específico correspondiente, y le pasa el V-node (o el puntero al i-nodo del sistema de ficheros específico que contiene) y los parámetros de la operación.
    3.  **Caché de búfer (Buffer Cache / Page Cache):**
        * Para mitigar la enorme latencia de la E/S de disco y mejorar el rendimiento del sistema de ficheros, suele haber una **caché de búfer** entre la capa de controladores de sistemas de ficheros específicos y la capa de controladores de dispositivos de bloque de nivel inferior.
        * Almacena en la memoria física los bloques de disco (o páginas de memoria, si es una caché de páginas) a los que se ha accedido recientemente.
        * Cuando un controlador de sistema de ficheros específico necesita leer un bloque de disco, primero solicita ese bloque a la caché de búfer.
            * **Acierto de caché (Cache Hit):** Si el bloque ya está en la caché, se obtiene rápidamente de la memoria, evitando un lento acceso al disco.
            * **Fallo de caché (Cache Miss):** Si el bloque no está en la caché, la caché de búfer se encarga de leer ese bloque desde el dispositivo físico (a través del controlador de dispositivo de bloque), lo almacena en la caché y luego lo proporciona al solicitante.
        * La caché de búfer aprovecha el **principio de localidad del acceso** (localidad temporal y espacial), es decir, es muy probable que los datos a los que se ha accedido recientemente (o los datos cercanos a ellos) vuelvan a ser accedidos en un futuro próximo. Aunque el tamaño de la caché sea mucho menor que la capacidad total del disco, puede alcanzar una tasa de aciertos muy alta.
        * Las operaciones de escritura también pueden optimizarse a través de la caché (por ejemplo, caché de escritura diferida o write-back cache), donde los datos se escriben primero en la caché y luego el mecanismo de gestión de la caché los escribe en el disco de forma asíncrona en un momento adecuado.
    4.  **Capa de controladores de dispositivos de bloque / Capa de controladores de dispositivos físicos:**
        * Es la capa más baja que se comunica directamente con los dispositivos de almacenamiento físico (como controladores de disco duro, controladores de SSD).
        * La caché de búfer (en caso de fallo de caché) o los controladores de sistemas de ficheros específicos de nivel superior (si se omite la caché o se realizan operaciones de control específicas) emiten comandos de lectura/escritura al dispositivo físico a través de los controladores de esta capa (generalmente dirigidos a un número de bloque lógico o LBA).
        * Estos controladores son responsables de traducir los números de bloque lógicos a comandos que el dispositivo físico puede entender (como comandos SATA o NVMe), manejar interrupciones de hardware y gestionar la transferencia de datos con el dispositivo.
* **Integración de gestores de dispositivos y descriptores de dispositivos:**
    * El concepto de **descriptores de dispositivo** (que contienen punteros a funciones de operación específicas) se extiende por múltiples capas: la capa de controladores de sistemas de ficheros específicos tiene su conjunto de funciones para la interfaz del VFS, mientras que la capa de controladores de dispositivos de bloque tiene su conjunto de funciones para la interfaz de hardware.
    * Los **gestores de dispositivos** (como se discutió en la Clase 4, responsables de la cola de solicitudes de E/S, bloqueo/despertar de hilos de usuario) suelen estar por debajo de la caché de búfer, o la propia caché de búfer integra esta funcionalidad de gestión. Interactúan con los controladores de dispositivos de bloque, manejan la E/S de hardware real y reciben notificaciones de finalización a través de interrupciones, etc. El VFS también puede desempeñar un papel de gestor parcial, por ejemplo, al recibir una llamada al sistema, si necesita esperar a la E/S, utilizará primitivas de sincronización (como semáforos) para bloquear el hilo de usuario y pasar la solicitud a la capa inferior.

Esta arquitectura en capas dota al sistema de ficheros de una gran flexibilidad y escalabilidad. Por ejemplo, añadir soporte para un nuevo tipo de sistema de ficheros generalmente solo requiere implementar un nuevo módulo de controlador de sistema de ficheros específico, sin necesidad de modificar el VFS u otros componentes centrales. Al mismo tiempo, mecanismos de optimización genéricos como la caché de búfer pueden servir a todos los tipos de sistemas de ficheros.